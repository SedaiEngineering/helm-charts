{{- if .Values.sedaiGrafanaAlloy.enabled }}
---
# Source: alloy/templates/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: sedai-grafana-alloy
  namespace: {{ .Release.Namespace }}
  labels:
    {{- include "sedai-smart-agent.labels" . | nindent 4 }}
    {{- with .Values.globalLabels }}
    {{- toYaml . | nindent 4 }}
    {{- end }}
  {{- with .Values.globalAnnotations }}
  annotations:
    {{- toYaml . | nindent 4 }}
  {{- end }}
    app.kubernetes.io/name: sedai-grafana-alloy
    app.kubernetes.io/component: config
data:
  config.alloy: |-
    logging {
      level  = "warn"
      format = "logfmt"
    }
    
    beyla.ebpf "networkflow" {
      discovery {
        services {
          kubernetes {
            namespace = "."
          }
        }
        exclude_services {
          exe_path = ".*alloy.*|.*otelcol.*|.*beyla.*"
        }
      }
      attributes {
        kubernetes {
          enable = "true"
        }
        select {
          attr  = "beyla_network_flow_bytes_total"
          exclude = []
          include = [
            "transport",
            "src_address",
            "dst_address",
            "src_name",
            "dst_name",
            "k8s_src_name",
            "k8s_dst_name",
            "k8s_src_namespace",
            "k8s_dst_namespace",
            "k8s_src_owner_name",
            "k8s_dst_owner_name",
            "k8s_src_owner_type",
            "k8s_dst_owner_type",
            "k8s_cluster_name",
            "src_zone",
            "dst_zone",
          ]
        }
      }
      filters {
        network {
          attr = "k8s.dst.owner.name"
          not_match = "{kube*,*jaeger-agent*,*prometheus*,*promtail*,*grafana-agent*}"
        }
        network {
          attr = "k8s.src.owner.name"
          not_match = "{kube*,*jaeger-agent*,*prometheus*,*promtail*,*grafana-agent*}"
        }
      }
      metrics {
        features = ["network", "application"]
      }
    }
    
    prometheus.scrape "beyla_network_flow" {
      targets      = beyla.ebpf.networkflow.targets
      honor_labels = true
      forward_to   = [prometheus.relabel.beyla_network_flow.receiver]
      }

    prometheus.relabel "beyla_network_flow" {
      rule {
        source_labels = ["__name__"]
        regex         = "beyla_network_flow_bytes_total"
        action        = "keep"
      }
      forward_to   = [prometheus.remote_write.victoriametrics.receiver]
    }
    
    discovery.kubernetes "kubernetes_apiservers" {
      role = "endpoints"
      
      selectors {
        role = "endpoints"
        field = "metadata.name=kubernetes"
      }
    }
    
    discovery.kubernetes "kubernetes_nodes" {
      role = "node"
      
      selectors {
        role = "node"
        field = "metadata.name=" + coalesce(sys.env("HOSTNAME"), constants.hostname)
      }
    }
    
    discovery.kubernetes "kubernetes_nodes_cadvisor" {
      role = "node"
      
      selectors {
        role = "node"
        field = "metadata.name=" + coalesce(sys.env("HOSTNAME"), constants.hostname)
      }
    }
    
    discovery.kubernetes "kubernetes_service_endpoints" {
      role = "endpoints"
    }
    
    prometheus.exporter.unix "node_exporter" {
      include_exporter_metrics = true
      
      // Enable additional collectors to get all required metrics
      set_collectors = [
        "boottime",
        "cpu",
        "diskstats", 
        "filesystem",
        "loadavg",
        "meminfo",
        "netdev",
        "netstat",
        "stat",
        "time",
        "uname",
        "vmstat",
      ]
      
      cpu {
        guest = true
      }
      
      filesystem {
        fs_types_exclude = "^(autofs|binfmt_misc|bpf|cgroup2?|configfs|debugfs|devpts|devtmpfs|fusectl|hugetlbfs|iso9660|mqueue|nsfs|overlay|proc|procfs|pstore|rpc_pipefs|securityfs|selinuxfs|squashfs|sysfs|tracefs)$"
        mount_points_exclude = "^/(dev|proc|run/credentials/.+|sys|var/lib/docker/.+)($|/)"
        mount_timeout = "5s"
      }
      netclass {
        ignored_devices = "^(veth.*|cali.*|[a-f0-9]{15})$"
      }
      netdev {
        device_exclude = "^(veth.*|cali.*|[a-f0-9]{15})$"
      }
    }

    discovery.relabel "kubernetes_apiservers" {
      targets = discovery.kubernetes.kubernetes_apiservers.targets
    
      rule {
        source_labels = ["__meta_kubernetes_namespace", "__meta_kubernetes_service_name", "__meta_kubernetes_endpoint_port_name"]
        regex         = "default;kubernetes;https"
        action        = "keep"
      }
    }
    
    discovery.relabel "kubernetes_nodes" {
      targets = discovery.kubernetes.kubernetes_nodes.targets
    
      rule {
        regex  = "__meta_kubernetes_node_label_(.+)"
        action = "labelmap"
      }
    
      rule {
        target_label = "__address__"
        replacement  = "kubernetes.default.svc:443"
      }
    
      rule {
        source_labels = ["__meta_kubernetes_node_name"]
        regex         = "(.+)"
        target_label  = "__metrics_path__"
        replacement   = "/api/v1/nodes/$1/proxy/metrics"
      }
    }
    
    discovery.relabel "kubernetes_nodes_cadvisor" {
      targets = discovery.kubernetes.kubernetes_nodes_cadvisor.targets
    
      rule {
        regex  = "__meta_kubernetes_node_label_(.+)"
        action = "labelmap"
      }
    
      rule {
        target_label = "__address__"
        replacement  = "kubernetes.default.svc:443"
      }
    
      rule {
        source_labels = ["__meta_kubernetes_node_name"]
        regex         = "(.+)"
        target_label  = "__metrics_path__"
        replacement   = "/api/v1/nodes/$1/proxy/metrics/cadvisor"
      }
    }
    
    discovery.relabel "kubernetes_service_endpoints" {
      targets = discovery.kubernetes.kubernetes_service_endpoints.targets
    
      // Filter for services with prometheus.io/scrape=true annotation
      rule {
        source_labels = ["__meta_kubernetes_service_annotation_prometheus_io_scrape"]
        regex         = "true"
        action        = "keep"
      }
    
      rule {
        source_labels = ["__meta_kubernetes_service_annotation_prometheus_io_scrape_slow"]
        regex         = "true"
        action        = "drop"
      }
    
      rule {
        source_labels = ["__meta_kubernetes_service_annotation_prometheus_io_scheme"]
        regex         = "(https?)"
        target_label  = "__scheme__"
      }
    
      rule {
        source_labels = ["__meta_kubernetes_service_annotation_prometheus_io_path"]
        regex         = "(.+)"
        target_label  = "__metrics_path__"
      }
    
      rule {
        source_labels = ["__address__", "__meta_kubernetes_service_annotation_prometheus_io_port"]
        regex         = "(.+?)(?::\\d+)?;(\\d+)"
        target_label  = "__address__"
        replacement   = "$1:$2"
      }
    
      rule {
        regex       = "__meta_kubernetes_service_annotation_prometheus_io_param_(.+)"
        replacement = "__param_$1"
        action      = "labelmap"
      }
    
      rule {
        regex  = "__meta_kubernetes_service_label_(.+)"
        action = "labelmap"
      }
    
      rule {
        source_labels = ["__meta_kubernetes_namespace"]
        target_label  = "namespace"
      }
    
      rule {
        source_labels = ["__meta_kubernetes_service_name"]
        target_label  = "service"
      }
    
      rule {
        source_labels = ["__meta_kubernetes_pod_node_name"]
        target_label  = "node"
      }
    }

    prometheus.scrape "node_exporter" {
      targets         = prometheus.exporter.unix.node_exporter.targets
      forward_to      = [prometheus.relabel.node_exporter.receiver]
      job_name        = "node-exporter"
      scrape_interval = "30s"
      scrape_timeout  = "10s"
    }
    
    prometheus.scrape "kubernetes_service_endpoints" {
      targets      = discovery.relabel.kubernetes_service_endpoints.output
      forward_to   = [prometheus.relabel.kubernetes_service_endpoints.receiver]
      job_name     = "kubernetes-service-endpoints"
      honor_labels = true
    }

    prometheus.scrape "kubernetes_apiservers" {
      targets    = discovery.relabel.kubernetes_apiservers.output
      forward_to = [prometheus.relabel.kubernetes_apiservers.receiver]
      job_name   = "kubernetes-apiservers"
      scheme     = "https"
    
      authorization {
        type             = "Bearer"
        credentials_file = "/var/run/secrets/kubernetes.io/serviceaccount/token"
      }
    
      tls_config {
        ca_file = "/var/run/secrets/kubernetes.io/serviceaccount/ca.crt"
      }
    }
    
    prometheus.scrape "kubernetes_nodes" {
      targets    = discovery.relabel.kubernetes_nodes.output
      forward_to = [prometheus.relabel.kubernetes_nodes.receiver]
      job_name   = "kubernetes-nodes"
      scheme     = "https"
    
      authorization {
        type             = "Bearer"
        credentials_file = "/var/run/secrets/kubernetes.io/serviceaccount/token"
      }
    
      tls_config {
        ca_file = "/var/run/secrets/kubernetes.io/serviceaccount/ca.crt"
      }
    }
    
    prometheus.scrape "kubernetes_nodes_cadvisor" {
      targets    = discovery.relabel.kubernetes_nodes_cadvisor.output
      forward_to = [prometheus.relabel.kubernetes_nodes_cadvisor.receiver]
      job_name   = "kubernetes-nodes-cadvisor"
      scheme     = "https"
    
      authorization {
        type             = "Bearer"
        credentials_file = "/var/run/secrets/kubernetes.io/serviceaccount/token"
      }
    
      tls_config {
        ca_file = "/var/run/secrets/kubernetes.io/serviceaccount/ca.crt"
      }
    }

    prometheus.relabel "kubernetes_service_endpoints" {
      forward_to = [prometheus.remote_write.victoriametrics.receiver]
    
      rule {
        source_labels = ["__name__"]
        regex         = "kube_daemonset_metadata_generation|kube_daemonset_status_current_number_scheduled|kube_daemonset_status_desired_number_scheduled|kube_daemonset_status_number_available|kube_daemonset_status_number_misscheduled|kube_daemonset_status_number_ready|kube_daemonset_status_number_unavailable|kube_deployment_metadata_generation|kube_deployment_status_observed_generation|kube_deployment_created|kube_deployment_status_replicas|kube_deployment_status_replicas_ready|kube_deployment_status_replicas_available|kube_deployment_status_replicas_unavailable|kube_deployment_status_replicas_updated|kube_horizontalpodautoscaler_info|kube_horizontalpodautoscaler_metadata_generation|kube_horizontalpodautoscaler_spec_max_replicas|kube_horizontalpodautoscaler_spec_min_replicas|kube_horizontalpodautoscaler_spec_target_metric|kube_horizontalpodautoscaler_status_current_replicas|kube_horizontalpodautoscaler_status_desired_replicas|kube_horizontalpodautoscaler_status_condition|kube_ingress_info|kube_ingress_metadata_resource_version|kube_ingress_path|kube_job_info|kube_job_spec_parallelism|kube_job_spec_completions|kube_job_status_succeeded|kube_job_status_failed|kube_job_status_active|kube_job_complete|kube_job_status_start_time|kube_job_status_completion_time|kube_job_owner|kube_lease_owner|kube_mutatingwebhookconfiguration_info|kube_mutatingwebhookconfiguration_created|kube_mutatingwebhookconfiguration_metadata_resource_version|kube_node_info|kube_node_spec_taint|kube_node_spec_unschedulable|kube_node_status_allocatable|kube_node_status_capacity|kube_persistentvolumeclaim_info|kube_persistentvolumeclaim_status_phase|kube_persistentvolumeclaim_resource_requests_storage_bytes|kube_persistentvolumeclaim_access_mode|kube_persistentvolume_claim_ref|kube_persistentvolume_status_phase|kube_persistentvolume_info|kube_persistentvolume_capacity_bytes|kube_persistentvolume_volume_mode|kube_poddisruptionbudget_created|kube_poddisruptionbudget_status_current_healthy|kube_poddisruptionbudget_status_desired_healthy|kube_poddisruptionbudget_status_pod_disruptions_allowed|kube_poddisruptionbudget_status_expected_pods|kube_pod_container_info|kube_pod_container_resource_limits|kube_pod_container_resource_requests|kube_pod_container_state_started|kube_pod_container_status_last_terminated_reason|kube_pod_container_status_last_terminated_exitcode|kube_pod_container_status_last_terminated_timestamp|kube_pod_container_status_restarts_total|kube_pod_container_status_running|kube_pod_container_status_terminated|kube_pod_container_status_terminated_reason|kube_pod_container_status_waiting|kube_pod_container_status_waiting_reason|kube_pod_info|kube_pod_init_container_info|kube_pod_init_container_resource_limits|kube_pod_init_container_resource_requests|kube_pod_init_container_status_ready|kube_pod_init_container_status_restarts_total|kube_pod_init_container_status_terminated_reason|kube_pod_init_container_status_waiting|kube_pod_init_container_status_waiting_reason|kube_pod_status_qos_class|kube_pod_tolerations|kube_pod_service_account|kube_pod_scheduler|kube_pod_start_time|kube_pod_status_phase|kube_pod_status_ready_time|kube_pod_status_scheduled_time|kube_replicaset_created|kube_replicaset_spec_replicas|kube_replicaset_metadata_generation|kube_replicaset_owner|kube_service_info|kube_service_spec_type|kube_service_status_load_balancer_ingress|kube_statefulset_created|kube_statefulset_status_replicas|kube_statefulset_status_replicas_available|kube_statefulset_status_replicas_current|kube_statefulset_status_replicas_ready|kube_statefulset_status_replicas_updated|kube_statefulset_replicas|kube_statefulset_metadata_generation|kube_statefulset_persistentvolumeclaim_retention_policy|kube_statefulset_status_current_revision|kube_statefulset_status_update_revision|kube_storageclass_info|kube_validatingwebhookconfiguration_info|kube_validatingwebhookconfiguration_metadata_resource_version|kube_validatingwebhookconfiguration_webhook_clientconfig_service|kube_volumeattachment_labels|kube_volumeattachment_info|kube_volumeattachment_spec_source_persistentvolume|kube_volumeattachment_status_attached|kube_volumeattachment_status_attachment_metadata"
        action        = "keep"
      }
    }
    
    prometheus.relabel "node_exporter" {
      forward_to = [prometheus.remote_write.victoriametrics.receiver]

      rule {
        source_labels = ["__name__"]
        regex         = "node_cpu_seconds_total|node_cpu_guest_seconds_total|node_disk_info|node_disk_io_time_seconds_total|node_disk_io_time_weighted_seconds_total|node_disk_read_bytes_total|node_disk_read_time_seconds_total|node_disk_writes_bytes_total|node_disk_write_time_seconds_total|node_dmi_info|node_load1|node_load15|node_load5|node_memory_MemAvailable_bytes|node_memory_MemFree_bytes|node_memory_MemTotal_bytes|node_netstat_Ip6_InOctets|node_netstat_Ip6_OutOctets|node_netstat_IpExt_InOctets|node_netstat_IpExt_OutOctets|node_network_receive_bytes_total|node_network_receive_packets_total|node_network_receive_drop_total|node_network_receive_errs_total|node_network_transmit_bytes_total|node_network_transmit_drop_total|node_network_transmit_errs_total|node_network_transmit_packets_total|node_os_info|node_selinux_config_mode"
        action        = "keep"
      }
    }

    prometheus.relabel "kubernetes_apiservers" {
      forward_to = [prometheus.remote_write.victoriametrics.receiver]

      rule {
        source_labels = ["__name__"]
        regex         = "kubernetes_build_info|kubernetes_feature_enabled"
        action        = "keep"
      }
    }
    
    prometheus.relabel "kubernetes_nodes" {
      forward_to = [prometheus.remote_write.victoriametrics.receiver]

      rule {
        source_labels = ["__name__"]
        regex         = "kubelet_active_pods|kubelet_desired_pods|kubelet_mirror_pods|kubelet_node_name|kubelet_managed_ephemeral_containers|kubelet_restarted_pods_total|kubelet_running_containers|kubelet_started_containers_total|kubelet_started_pods_errors_total|kubelet_started_pods_total|kubelet_evictions"
        action        = "keep"
      }
    }
    
    prometheus.relabel "kubernetes_nodes_cadvisor" {
      forward_to = [prometheus.remote_write.victoriametrics.receiver]

      rule {
        source_labels = ["__name__"]
        regex         = "container_cpu_cfs_periods_total|container_cpu_cfs_throttled_periods_total|container_cpu_cfs_throttled_seconds_total|container_cpu_system_seconds_total|container_cpu_usage_seconds_total|container_cpu_user_seconds_total|container_fs_io_time_seconds_total|container_fs_io_time_weighted_seconds_total|container_memory_cache|container_memory_failcnt|container_memory_failures_total|container_memory_max_usage_bytes|container_memory_rss|container_memory_swap|container_memory_total_active_file_bytes|container_memory_total_inactive_file_bytes|container_memory_usage_bytes|container_memory_working_set_bytes|container_network_receive_bytes_total|container_network_receive_errors_total|container_network_receive_packets_dropped_total|container_network_transmit_bytes_total|container_network_transmit_errors_total|container_network_receive_packets_total|container_network_transmit_packets_dropped_total|container_network_transmit_packets_total|container_oom_events_total|container_sockets|container_processes|container_spec_cpu_period|container_spec_cpu_quota|container_spec_memory_limit_bytes|container_threads|container_threads_max"
        action        = "keep"
      }
    }
    
    prometheus.remote_write "victoriametrics" {
      endpoint {
        url = "http://sedai-victoria-metrics-server.{{ .Release.Namespace }}:8428/api/v1/write"
      }
    }
{{- end }}
