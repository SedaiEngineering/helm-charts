{{- if .Values.sedaiGrafanaAlloy.enabled }}
---
# Source: alloy/templates/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: sedai-grafana-alloy
  namespace: {{ .Values.namespace }}
  labels:
    {{- include "sedai-smart-agent.labels" . | nindent 4 }}
    {{- with .Values.globalLabels }}
    {{- toYaml . | nindent 4 }}
    {{- end }}
    app.kubernetes.io/name: sedai-grafana-alloy
    app.kubernetes.io/component: config
data:
  config.alloy: |-
    logging {
      level  = "info"
      format = "logfmt"
    }
    
    beyla.ebpf "networkflow" {
      discovery {
        services {
          kubernetes {
          namespace = "."
          }
        }
        exclude_services {
          exe_path = ".*alloy.*|.*otelcol.*|.*beyla.*"
        }
      }
      attributes {
        kubernetes {
          enable = "true"
        }
        select {
          attr  = "beyla_network_flow_bytes_total"
          exclude = []
          include = [
            "transport",
            "src_address",
            "dst_address",
            "src_name",
            "dst_name",
            "k8s_src_name",
            "k8s_dst_name",
            "k8s_src_namespace",
            "k8s_dst_namespace",
            "k8s_src_owner_name",
            "k8s_dst_owner_name",
            "k8s_src_owner_type",
            "k8s_dst_owner_type",
            "k8s_cluster_name",
            "src_zone",
            "dst_zone",
          ]
        }
      }
      filters {
        network {
          attr = "k8s.dst.owner.name"
          not_match = "{kube*,*jaeger-agent*,*prometheus*,*promtail*,*grafana-agent*}"
        }
        network {
          attr = "k8s.src.owner.name"
          not_match = "{kube*,*jaeger-agent*,*prometheus*,*promtail*,*grafana-agent*}"
        }
      }
      metrics {
        features = ["network", "application"]
      }
    }
    
    prometheus.scrape "beyla_network_flow" {
      targets      = beyla.ebpf.networkflow.targets
      honor_labels = true
      forward_to   = [prometheus.relabel.beyla_network_flow.receiver]
      }

    prometheus.relabel "beyla_network_flow" {
      rule {
        source_labels = ["__name__"]
        regex         = "beyla_network_flow_bytes_total"
        action        = "keep"
      }
      forward_to   = [prometheus.remote_write.victoriametrics.receiver]
    }
    
    discovery.kubernetes "kubernetes_apiservers" {
      role = "endpoints"
    }
    
    discovery.kubernetes "kubernetes_nodes" {
      role = "node"
    }
    
    discovery.kubernetes "kubernetes_nodes_cadvisor" {
      role = "node"
    }
    
    prometheus.exporter.unix "node_exporter" {
      include_exporter_metrics = true
      filesystem {
        fs_types_exclude = "^(autofs|binfmt_misc|bpf|cgroup2?|configfs|debugfs|devpts|devtmpfs|fusectl|hugetlbfs|iso9660|mqueue|nsfs|overlay|proc|procfs|pstore|rpc_pipefs|securityfs|selinuxfs|squashfs|sysfs|tracefs)$"
        mount_points_exclude = "^/(dev|proc|run/credentials/.+|sys|var/lib/docker/.+)($|/)"
        mount_timeout = "5s"
      }
      netclass {
        ignored_devices = "^(veth.*|cali.*|[a-f0-9]{15})$"
      }
      netdev {
        device_exclude = "^(veth.*|cali.*|[a-f0-9]{15})$"
      }
    }
    
    discovery.relabel "kubernetes_apiservers" {
      targets = discovery.kubernetes.kubernetes_apiservers.targets
    
      rule {
        source_labels = ["__meta_kubernetes_namespace", "__meta_kubernetes_service_name", "__meta_kubernetes_endpoint_port_name"]
        regex         = "default;kubernetes;https"
        action        = "keep"
      }
    }
    
    discovery.relabel "kubernetes_nodes" {
      targets = discovery.kubernetes.kubernetes_nodes.targets
    
      rule {
        regex  = "__meta_kubernetes_node_label_(.+)"
        action = "labelmap"
      }
    
      rule {
        target_label = "__address__"
        replacement  = "kubernetes.default.svc:443"
      }
    
      rule {
        source_labels = ["__meta_kubernetes_node_name"]
        regex         = "(.+)"
        target_label  = "__metrics_path__"
        replacement   = "/api/v1/nodes/$1/proxy/metrics"
      }
    }
    
    discovery.relabel "kubernetes_nodes_cadvisor" {
      targets = discovery.kubernetes.kubernetes_nodes_cadvisor.targets
    
      rule {
        regex  = "__meta_kubernetes_node_label_(.+)"
        action = "labelmap"
      }
    
      rule {
        target_label = "__address__"
        replacement  = "kubernetes.default.svc:443"
      }
    
      rule {
        source_labels = ["__meta_kubernetes_node_name"]
        regex         = "(.+)"
        target_label  = "__metrics_path__"
        replacement   = "/api/v1/nodes/$1/proxy/metrics/cadvisor"
      }
    }
    
    prometheus.scrape "node_exporter" {
      targets    = prometheus.exporter.unix.node_exporter.targets
      forward_to = [prometheus.relabel.node_exporter.receiver]
      job_name   = "node-exporter"
    }
    
    prometheus.scrape "prometheus" {
      targets = [{
        __address__ = "localhost:9090",
      }]
      forward_to = [prometheus.relabel.prometheus.receiver]
      job_name   = "prometheus"
    }
    
    prometheus.scrape "kubernetes_apiservers" {
      targets    = discovery.relabel.kubernetes_apiservers.output
      forward_to = [prometheus.relabel.kubernetes_apiservers.receiver]
      job_name   = "kubernetes-apiservers"
      scheme     = "https"
    
      authorization {
        type             = "Bearer"
        credentials_file = "/var/run/secrets/kubernetes.io/serviceaccount/token"
      }
    
      tls_config {
        ca_file = "/var/run/secrets/kubernetes.io/serviceaccount/ca.crt"
      }
    }
    
    prometheus.scrape "kubernetes_nodes" {
      targets    = discovery.relabel.kubernetes_nodes.output
      forward_to = [prometheus.relabel.kubernetes_nodes.receiver]
      job_name   = "kubernetes-nodes"
      scheme     = "https"
    
      authorization {
        type             = "Bearer"
        credentials_file = "/var/run/secrets/kubernetes.io/serviceaccount/token"
      }
    
      tls_config {
        ca_file = "/var/run/secrets/kubernetes.io/serviceaccount/ca.crt"
      }
    }
    
    prometheus.scrape "kubernetes_nodes_cadvisor" {
      targets    = discovery.relabel.kubernetes_nodes_cadvisor.output
      forward_to = [prometheus.relabel.kubernetes_nodes_cadvisor.receiver]
      job_name   = "kubernetes-nodes-cadvisor"
      scheme     = "https"
    
      authorization {
        type             = "Bearer"
        credentials_file = "/var/run/secrets/kubernetes.io/serviceaccount/token"
      }
    
      tls_config {
        ca_file = "/var/run/secrets/kubernetes.io/serviceaccount/ca.crt"
      }
    }
    
    prometheus.relabel "node_exporter" {
      forward_to = [prometheus.remote_write.victoriametrics.receiver]

      rule {
        source_labels = ["__name__"]
        regex         = "node_disk_info|node_dmi_info|node_load1|node_load15|node_load5|node_memory_MemAvailable_bytes|node_memory_MemFree_bytes|node_memory_MemTotal_bytes|node_netstat_Ip6_InOctets|node_netstat_Ip6_OutOctets|node_netstat_IpExt_InOctets|node_netstat_IpExt_OutOctets|node_network_receive_bytes_total|node_network_receive_packets_total|node_network_receive_drop_total|node_network_receive_errs_total|node_network_transmit_bytes_total|node_network_transmit_drop_total|node_network_transmit_errs_total|node_network_transmit_packets_total|node_os_info|node_selinux_config_mode|process_network_receive_bytes_total|process_network_transmit_bytes_total|node_cpu_guest_seconds_total|node_cpu_seconds_total|node_disk_io_time_seconds_total|node_disk_io_time_weighted_seconds_total|node_disk_read_bytes_total|node_disk_read_time_seconds_total|node_disk_writes_bytes_total|node_disk_write_time_seconds_total"
        action        = "keep"
      }
    }
    
    prometheus.relabel "prometheus" {
      forward_to = [prometheus.remote_write.victoriametrics.receiver]

      rule {
        source_labels = ["__name__"]
        regex         = "prometheus_build_info|prometheus_config_last_reload_success_timestamp_seconds|prometheus_ready"
        action        = "keep"
      }
    }
    
    prometheus.relabel "kubernetes_apiservers" {
      forward_to = [prometheus.remote_write.victoriametrics.receiver]

      rule {
        source_labels = ["__name__"]
        regex         = "kubernetes_build_info|kubernetes_feature_enabled"
        action        = "keep"
      }
    }
    
    prometheus.relabel "kubernetes_nodes" {
      forward_to = [prometheus.remote_write.victoriametrics.receiver]

      rule {
        source_labels = ["__name__"]
        regex         = "kubelet_active_pods|kubelet_desired_pods|kubelet_mirror_pods|kubelet_node_name|kubelet_managed_ephemeral_containers|kubelet_restarted_pods_total|kubelet_running_containers|kubelet_started_containers_total|kubelet_started_pods_errors_total|kubelet_started_pods_total|kubelet_evictions"
        action        = "keep"
      }
    }
    
    prometheus.relabel "kubernetes_nodes_cadvisor" {
      forward_to = [prometheus.remote_write.victoriametrics.receiver]

      rule {
        source_labels = ["__name__"]
        regex         = "container_cpu_cfs_periods_total|container_cpu_cfs_throttled_periods_total|container_cpu_cfs_throttled_seconds_total|container_cpu_system_seconds_total|container_cpu_usage_seconds_total|container_cpu_user_seconds_total|container_fs_io_time_seconds_total|container_fs_io_time_weighted_seconds_total|container_memory_cache|container_memory_failcnt|container_memory_failures_total|container_memory_max_usage_bytes|container_memory_rss|container_memory_swap|container_memory_total_active_file_bytes|container_memory_total_inactive_file_bytes|container_memory_usage_bytes|container_memory_working_set_bytes|container_network_receive_bytes_total|container_network_receive_errors_total|container_network_receive_packets_dropped_total|container_network_transmit_bytes_total|container_network_transmit_errors_total|container_network_receive_packets_total|container_network_transmit_packets_dropped_total|container_network_transmit_packets_total|container_oom_events_total|container_sockets|container_processes|container_spec_cpu_period|container_spec_cpu_quota|container_spec_memory_limit_bytes|container_threads|container_threads_max"
        action        = "keep"
      }
    }
    
    prometheus.remote_write "victoriametrics" {
      endpoint {
        url = "http://sedai-victoria-metrics-server.{{ .Values.namespace }}:8428/api/v1/write"
      }
    }
{{- end }}
